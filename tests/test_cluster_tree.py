from __future__ import annotations

import networkx as nx
import pytest

from scanpy.plotting._cluster_tree import cluster_decision_tree
from scanpy.tools._cluster_resolution import cluster_resolution_finder


@pytest.fixture
def adata_with_clusters(adata_for_test):
    """Fixture providing clustering data and top_genes_dict for cluster_decision_tree."""
    adata = adata_for_test.copy()
    resolutions = [0.0, 0.2, 0.5, 1.0, 1.5, 2.0]
    cluster_resolution_finder(
        adata,
        resolutions,
        prefix="leiden_res_",
        n_top_genes=2,
        min_cells=2,
        deg_mode="within_parent",
        flavor="igraph",
        n_iterations=2,
    )
    return adata, resolutions


# # Test 0: Image comparison
# @pytest.mark.mpl_image_compare
# def test_cluster_decision_tree_plot(adata_with_clusters, image_comparer):
#     """Test that the plot generated by cluster_decision_tree matches the expected output."""
#     adata, resolutions = adata_with_clusters

#     # Set a random seed for reproducibility
#     np.random.seed(42)

#     # Generate the plot with the same parameters used to create expected.png
#     cluster_decision_tree(
#         adata=adata,
#         resolutions=resolutions,
#         prefix="leiden_res_",
#         node_spacing=5.0,
#         level_spacing=1.5,
#         draw=True,
#         output_path=None,  # Let image_comparer handle saving the plot
#         figsize=(6.98, 5.55),
#         dpi=40,
#         node_size=200,
#         node_colormap=["Blues", "red", "#00FF00", "plasma", "Set3", "tab20"],
#         node_label_fontsize=8,
#         edge_curvature=0.01,
#         edge_threshold=0.05,
#         edge_label_threshold=0.05,
#         edge_label_position=0.5,
#         edge_label_fontsize=4,
#         show_gene_labels=True,
#         n_top_genes=2,
#         gene_label_offset=0.4,
#         gene_label_fontsize=5,
#         gene_label_threshold=0.001,
#         level_label_offset=15,
#         level_label_fontsize=8,
#         title="Hierarchical Leiden Clustering",
#         title_fontsize=8,
#     )

#     # Use image_comparer to compare the plot
#     image_comparer(Path("tests/_images"), "cluster_decision_tree_plot", tol=50)


# Test 1: Basic functionality without gene labels
def test_cluster_decision_tree_basic(adata_with_clusters):
    """Test that cluster_decision_tree runs without errors and returns a graph."""
    adata, resolutions = adata_with_clusters

    G = cluster_decision_tree(
        adata=adata,
        prefix="leiden_res_",
        resolutions=resolutions,
        draw=False,  # Don't draw during tests to avoid opening plot windows
    )

    # Check that the output is a directed graph
    assert isinstance(G, nx.DiGraph)

    # Check that the graph has nodes and edges
    assert len(G.nodes) > 0
    assert len(G.edges) > 0

    # Check that nodes have resolution and cluster attributes
    for node in G.nodes:
        assert "resolution" in G.nodes[node]
        assert "cluster" in G.nodes[node]


# Test 2: Basic functionality with gene labels
def test_cluster_decision_tree_with_gene_labels(adata_with_clusters):
    """Test that cluster_decision_tree handles gene labels when show_gene_labels is True."""
    adata, resolutions = adata_with_clusters

    G = cluster_decision_tree(
        adata=adata,
        prefix="leiden_res_",
        resolutions=resolutions,
        show_gene_labels=True,
        n_top_genes=2,
        draw=False,
    )

    # Check that the graph is still valid
    assert isinstance(G, nx.DiGraph)
    assert len(G.nodes) > 0
    assert len(G.edges) > 0


# Test 3: Error condition (show_gene_labels=True but top_genes_dict missing in adata.uns)
def test_cluster_decision_tree_missing_top_genes_dict(adata_with_clusters):
    """Test that show_gene_labels=True raises an error if top_genes_dict is missing in adata.uns."""
    adata, resolutions = adata_with_clusters

    # Remove top_genes_dict from adata.uns
    del adata.uns["cluster_resolution_top_genes"]

    with pytest.raises(
        ValueError, match="adata.uns\\['cluster_resolution_top_genes'\\] not found"
    ):
        cluster_decision_tree(
            adata=adata,
            prefix="leiden_res_",
            resolutions=resolutions,
            show_gene_labels=True,
            draw=False,
        )


# Test 4: Conflicting arguments (negative node_size)
def test_cluster_decision_tree_negative_node_size(adata_with_clusters):
    """Test that a negative node_size raises a ValueError."""
    adata, resolutions = adata_with_clusters

    with pytest.raises(ValueError, match="node_size must be a positive number"):
        cluster_decision_tree(
            adata=adata,
            prefix="leiden_res_",
            resolutions=resolutions,
            node_size=-100,
            draw=False,
        )


# Test 5: Error conditions (invalid figsize)
def test_cluster_decision_tree_invalid_figsize(adata_with_clusters):
    """Test that an invalid figsize raises a ValueError."""
    adata, resolutions = adata_with_clusters

    with pytest.raises(
        ValueError, match="figsize must be a tuple of two positive numbers"
    ):
        cluster_decision_tree(
            adata=adata,
            prefix="leiden_res_",
            resolutions=resolutions,
            figsize=(0, 5),  # Invalid: width <= 0
            draw=False,
        )


# Test 6: Helpful error message (missing cluster_data in adata.uns)
def test_cluster_decision_tree_missing_cluster_data(adata_with_clusters):
    """Test that a missing cluster_data in adata.uns raises a ValueError."""
    adata, resolutions = adata_with_clusters

    # Remove cluster_data from adata.uns
    del adata.uns["cluster_resolution_cluster_data"]

    with pytest.raises(
        ValueError, match="adata.uns\\['cluster_resolution_cluster_data'\\] not found"
    ):
        cluster_decision_tree(
            adata=adata,
            prefix="leiden_res_",
            resolutions=resolutions,
            draw=False,
        )


# Test 7: Orthogonal effects (draw argument)
def test_cluster_decision_tree_draw_argument(adata_with_clusters):
    """Test that the draw argument doesn't affect the graph output."""
    adata, resolutions = adata_with_clusters

    # Run with draw=False
    G_no_draw = cluster_decision_tree(
        adata=adata,
        prefix="leiden_res_",
        resolutions=resolutions,
        draw=False,
    )

    # Run with draw=True (but mock plt.show to avoid opening a window)
    from unittest import mock

    with mock.patch("matplotlib.pyplot.show"):
        G_draw = cluster_decision_tree(
            adata=adata,
            prefix="leiden_res_",
            resolutions=resolutions,
            draw=True,
        )

    # Check that the graphs are the same
    assert nx.is_isomorphic(G_no_draw, G_draw)
    assert G_no_draw.nodes(data=True) == G_draw.nodes(data=True)

    # Convert edge attributes to a hashable form
    def make_edge_hashable(edges):
        return {
            (
                u,
                v,
                tuple(
                    (k, tuple(v) if isinstance(v, list) else v)
                    for k, v in sorted(d.items())
                ),
            )
            for u, v, d in edges
        }

    # Compare edges as sets to ignore order
    assert make_edge_hashable(G_no_draw.edges(data=True)) == make_edge_hashable(
        G_draw.edges(data=True)
    )


# Test 8: Equivalent inputs (node_colormap)
@pytest.mark.parametrize(
    "node_colormap",
    [
        None,
        ["Set3", "Set3"],  # Same colormap for both resolutions
    ],
)
def test_cluster_decision_tree_node_colormap(adata_with_clusters, node_colormap):
    """Test that node_colormap=None and a uniform colormap produce similar results."""
    adata, resolutions = adata_with_clusters

    G = cluster_decision_tree(
        adata=adata,
        prefix="leiden_res_",
        resolutions=resolutions,
        node_colormap=node_colormap,
        draw=False,
    )
    # Check that the graph structure is the same regardless of colormap
    assert isinstance(G, nx.DiGraph)
    assert len(G.nodes) > 0


# Test 9: Bounds on gene labels (n_top_genes)
@pytest.mark.parametrize("n_top_genes", [1, 3])
def test_cluster_decision_tree_n_top_genes(adata_with_clusters, n_top_genes):
    """Test that n_top_genes bounds the number of gene labels when show_gene_labels=True."""
    adata, resolutions = adata_with_clusters
    resolutions = [0.0, 0.2, 0.5]

    # Run cluster_resolution_finder with different n_top_genes
    cluster_resolution_finder(
        adata,
        resolutions,
        n_top_genes=n_top_genes,
    )

    # Mock draw_cluster_tree to capture the number of genes used
    from unittest import mock

    with mock.patch("scanpy.plotting._cluster_tree.draw_cluster_tree") as mock_draw:
        cluster_decision_tree(
            adata=adata,
            prefix="leiden_res_",
            resolutions=resolutions,
            show_gene_labels=True,
            n_top_genes=n_top_genes,
            draw=False,
        )
        # Check the n_top_genes argument passed to draw_cluster_tree
        if mock_draw.called:
            _, kwargs = mock_draw.call_args
            assert kwargs["n_top_genes"] == n_top_genes
